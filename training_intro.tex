As shown in the previous section, \textsc{Nenwin} is capable to simulate a CPU. Given that the RAM model is Turing complete, \textsc{Nenwin} is a Turing complete computational method as well. However, \textsc{Nenwin} has a very dynamic nature with complex interactions between particles, especially for larger architectures. This makes it unpractical to design architectures manually; automated optimization, or 'training', is needed for any practical application. 

The goal of the training is to set up the architecture of Nodes, such that on a specific input $x \in \mathbb{R}^n$, $n \in \mathbb{N^+}$, given at a point in time $t = t_x$, leads to a desired output $y \in \mathbb{R}^m$, $m \in \mathbb{N^+}$ at a specific time $t = t_y > t_0$. Note that the way $y$ is represented by the \textsc{Nenwin} model can be defined in multiple ways.